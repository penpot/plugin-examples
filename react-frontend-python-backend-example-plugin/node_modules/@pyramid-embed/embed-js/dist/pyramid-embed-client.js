import { wait } from './helper-utils';
import { HubClient } from './hub-client';
var EmbedClientStatus;
(function (EmbedClientStatus) {
    EmbedClientStatus[EmbedClientStatus["NotInitialized"] = 0] = "NotInitialized";
    EmbedClientStatus[EmbedClientStatus["Initializing"] = 1] = "Initializing";
    EmbedClientStatus[EmbedClientStatus["Initialized"] = 2] = "Initialized";
})(EmbedClientStatus || (EmbedClientStatus = {}));
const fakeEmbedFnName = 'fakeEmbed';
const waitForLoadInterval = 200;
export class PyramidEmbedClient {
    constructor(host, userName, password, customData) {
        this.status = EmbedClientStatus.NotInitialized;
        this.embedQueue = [];
        if (!host)
            throw Error("host can't be empty");
        this._host = getActualHost(host);
        this.init(userName, password, customData);
    }
    get host() {
        return this._host;
    }
    get isClientLoaded() {
        return clientLoaded();
    }
    get isLoggedIn() {
        return this.hasCookie();
    }
    static quickEmbed(options) {
        const instance = new PyramidEmbedClient(options.host);
        instance.init(options.userName, options.password, options.customData).then(() => {
            instance.embed(options.container, options);
        });
        return instance;
    }
    async init(userName, password, customData) {
        if (this.isClientLoaded && this.isLoggedIn) {
            return null;
        }
        if ((!userName || !password) && !this.isLoggedIn) {
            //throw error?
            return null;
        }
        const token = !this.isLoggedIn ? await this.login(userName, password, customData) : null;
        getLegacyEmbed(this.host.toString());
        return token;
    }
    setAuthToken(token) {
        this.setTokenCookie(token);
    }
    getAuthToken() {
        if (this.hasCookie()) {
            return this.getTokenCookie();
        }
        return null;
    }
    async setAuthFailureCallback(callback) {
        await this.waitForClientToLoad();
        pyramid.authFailure = callback;
    }
    getCleanHostURL() {
        //remove trailing slash
        return this.host.href.replace(/\/$/, '');
    }
    async hub(container, options = {}) {
        addSpinner(container);
        await this.waitForClientToLoad();
        const embedOptions = {
            host: this.getCleanHostURL(),
            theme: options.theme,
            style: options.style,
            editable: options.editable,
            showTabs: options.showTabs,
            responsiveness: options.responsiveness,
            locale: options.locale,
            smartReportDialogPopupMode: options.smartReportDialogPopupMode,
            template: options.template,
        };
        const hubApi = pyramid.hub;
        await hubApi.embed(container, embedOptions);
        return new HubClient(hubApi);
    }
    async waitForClientToLoad() {
        if (this.isClientLoaded)
            return;
        await wait(waitForLoadInterval);
        return this.waitForClientToLoad();
    }
    //legacy embed. keep as is
    async embed(container, options) {
        var _a, _b;
        addSpinner(container);
        await this.waitForClientToLoad();
        const params = {
            reportFilters: (_a = options.filters) === null || _a === void 0 ? void 0 : _a.toGlobalEmbedFilters(),
            targets: (_b = options.targets) === null || _b === void 0 ? void 0 : _b.toGlobalEmbedTarget(),
            slideNumber: options.slideNumber,
        };
        const embedOptions = {
            id: options.contentId,
            contentType: options.visualOnly ? 'visual' : null,
            host: this.getCleanHostURL(),
            onLoad: options.onLoad,
            params: params,
            deviceType: options.deviceType,
            theme: options.theme,
            locale: options.locale,
            exporting: options.exporting,
            fullDiscovery: options.fullDiscovery,
        };
        if (this.status === EmbedClientStatus.Initializing) {
            this.addEmbedRequestToQueue({ container, embedOptions });
            return;
        }
        const embedPromise = pyramid.embed(container, embedOptions);
        if (this.status === EmbedClientStatus.NotInitialized) {
            this.setStatus(EmbedClientStatus.Initializing);
            await embedPromise;
            this.embedQueue.forEach(({ container, embedOptions }) => {
                pyramid.embed(container, embedOptions);
            });
            this.setStatus(EmbedClientStatus.Initialized);
        }
    }
    async login(userName, password, customData) {
        const credentials = {
            data: {
                userName: userName,
                password: password,
                domain: document.domain,
                customData,
            },
        };
        const token = await this.loginInternal(`${this.host.href}API2/auth/authenticateUserEmbed`, {
            method: 'POST',
            body: JSON.stringify(credentials),
        });
        this.setTokenCookie(token);
        return token;
    }
    async loginWindowsAuth() {
        const credentials = { data: { domain: document.domain } };
        const token = await this.loginInternal(`${this.host.href}API2/auth/authenticateUserEmbedWindows`, {
            method: 'POST',
            credentials: 'include',
            body: JSON.stringify(credentials),
        });
        this.setTokenCookie(token);
        return token;
    }
    async loginSamlAuth(samlToken, customData) {
        const credentials = {
            data: { domain: document.domain, token: samlToken, customData },
        };
        const token = await this.loginInternal(`${this.host.href}API2/auth/authenticateUserEmbedSAML`, {
            method: 'POST',
            body: JSON.stringify(credentials),
        });
        this.setTokenCookie(token);
        return token;
    }
    async loginOpenIdAuth(openIdToken, customData) {
        const credentials = {
            data: { domain: document.domain, parameterMap: { id_token: openIdToken }, customData },
        };
        const token = await this.loginInternal(`${this.host.href}API2/auth/authenticateUserEmbedOPENID`, {
            method: 'POST',
            body: JSON.stringify(credentials),
        });
        this.setTokenCookie(token);
        return token;
    }
    setStatus(status) {
        this.status = status;
    }
    addEmbedRequestToQueue(embedTask) {
        this.embedQueue.push(embedTask);
    }
    async loginInternal(requestInfo, requestInit) {
        let errorMessage;
        try {
            const response = await fetch(requestInfo, requestInit);
            if (!response) {
                errorMessage = 'Unknown Login Error';
            }
            else if (response.status === 401) {
                errorMessage = 'Login failed';
            }
            else if (response.status !== 200) {
                errorMessage = 'Unknown Login Error';
            }
            else {
                const token = await response.text();
                return token;
            }
        }
        catch (error) {
            const errorMsg = typeof error === 'string' ? error : error === null || error === void 0 ? void 0 : error.message;
            errorMessage = `Login Error: ${errorMsg}`;
        }
        if (errorMessage) {
            throw new Error(errorMessage);
        }
    }
    hasCookie() {
        var _a;
        return ((_a = document.cookie.match(/^(.*;)?\s*PyramidEmbeddedAuth\s*=\s*[^;]+(.*)?$/)) === null || _a === void 0 ? void 0 : _a.length) > 0;
    }
    setTokenCookie(val) {
        document.cookie = `PyramidEmbeddedAuth=${val}`;
    }
    getTokenCookie() {
        const name = 'PyramidEmbeddedAuth=';
        const decodedCookie = decodeURIComponent(document.cookie);
        const ca = decodedCookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) == ' ') {
                c = c.substring(1);
            }
            if (c.indexOf(name) == 0) {
                return c.substring(name.length, c.length);
            }
        }
        return '';
    }
}
function getActualHost(host) {
    const actualHost = !host.startsWith('http://') && !host.startsWith('https://') ? `http://${host}` : host;
    return new URL(actualHost);
}
function getLegacyEmbed(host) {
    if (clientLoaded())
        return;
    let headExists = false;
    Array.from(document.querySelectorAll('script')).forEach(x => {
        var _a;
        if ((_a = x.src) === null || _a === void 0 ? void 0 : _a.includes('no-shell/embed.js')) {
            headExists = true;
        }
    });
    if (!headExists) {
        const scriptElem = document.createElement('script');
        scriptElem.src = `${host}no-shell/embed.js?v=${new Date().getTime()}`;
        scriptElem.async = true;
        document.head.appendChild(scriptElem);
    }
}
function tryLoadStaticEmbed() {
    const staticEmbedElement = document.querySelector('.pyramid-embed.pyramid-auto[data-host]');
    if (staticEmbedElement) {
        getLegacyEmbed(getActualHost(staticEmbedElement.getAttribute('data-host')).toString());
    }
}
function clientLoaded() {
    const pyramid = window.pyramid;
    const embedFn = pyramid === null || pyramid === void 0 ? void 0 : pyramid.embed;
    // check that the embed function exists and that it's not the fake api
    // displayName will only appear in newer versions and will only be checked if exists
    return !!embedFn && (!embedFn.displayName || embedFn.displayName !== fakeEmbedFnName);
}
function addSpinner(container) {
    if (!container) {
        return;
    }
    if (container.childNodes.length > 0) {
        return;
    }
    if (clientLoaded()) {
        return;
    }
    createSpinnerStyleIfNeeded();
    const spinnerHtml = `
	  <div style="display: flex; align-items: center; width: 100%; height: 100%; background-color: #fff; opacity: 0.8">
		<div class="pre-loading-spinner-animation-container">
		  <div class="pre-loading-spinner-animation-bars">
			<div></div>
			<div></div>
			<div></div>
			<div></div>
		  </div>
		</div>
	  </div>`.trim();
    container.insertAdjacentHTML('beforeend', spinnerHtml);
}
function getSpinnerStyle() {
    return document.querySelector('style[data-pyramid-embed-client]');
}
function createSpinnerStyleIfNeeded() {
    const spinnerStyle = getSpinnerStyle();
    if (spinnerStyle) {
        return;
    }
    const color = '#555555';
    const css = `
	  .pre-loading-spinner-animation-container {
		display: flex;
		justify-content: center;
		width: 100%;
	  }
	  @keyframes app-pre-loading-spinner-bars-random-animation {
		0% {
		  transform: scale(1);
		}
		50% {
		  transform: scale(0.5);
		}
		100% {
		  transform: scale(1);
		}
	  }
	  .pre-loading-spinner-animation-bars {
		font-size: 0;
	  }
	  .pre-loading-spinner-animation-bars > div:nth-child(1) {
		animation-delay: 0.48s;
		animation-duration: 0.54s;
	  }
	  .pre-loading-spinner-animation-bars > div:nth-child(2) {
		animation-delay: -0.15s;
		animation-duration: 1.15s;
	  }
	  .pre-loading-spinner-animation-bars > div:nth-child(3) {
		animation-delay: 0.04s;
		animation-duration: 0.77s;
	  }
	  .pre-loading-spinner-animation-bars > div:nth-child(4) {
		animation-delay: -0.12s;
		animation-duration: 0.61s;
	  }
	  .pre-loading-spinner-animation-bars > div {
		background-color: ${color};
		width: 2px;
		height: 22px;
		border-radius: 2px;
		margin: 2px;
		animation-fill-mode: both;
		display: inline-block;
		animation-name: app-pre-loading-spinner-bars-random-animation;
		animation-iteration-count: infinite;
		animation-delay: 0s;
	  }`
        .trim()
        .replace(/\n/g, '')
        .replace(/\s\s+/g, ' ');
    const style = `<style data-pyramid-embed-client>${css}</style>`;
    document.head.insertAdjacentHTML('beforeend', style);
}
document.addEventListener('DOMContentLoaded', function () {
    tryLoadStaticEmbed();
});
